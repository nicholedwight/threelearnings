<!DOCTYPE html>
<html lang="en">

<head>
	<title>three.js canvas - geometry - cube</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<style>
		body {
			font-family: Monospace;
			background-color: #f0f0f0;
			margin: 0px;
			overflow: hidden;
		}
		#status {
				position:absolute;
				width:25%;
				left:2%;
				top:70%;
				height:5%;
				opacity:.9;
				font: 13px/1.231 "Lucida Grande", Lucida, Verdana, sans-serif;
			}
	</style>
</head>

<body>
	<div id="status"></div>
	<script src="js/three.js"></script>

	<script src="js/renderers/Projector.js"></script>
	<script src="js/renderers/CanvasRenderer.js"></script>

	<script src="js/libs/stats.min.js"></script>

	<script>
		var container, stats;

		var camera, scene, renderer;

		var cube, plane, root;

		var targetRotation = 0;
		var targetRotationOnMouseDown = 0;

		var mouseX = 0;
		var mouseXOnMouseDown = 0;

		var windowHalfX = window.innerWidth / 2;
		var windowHalfY = window.innerHeight / 2;
		init();
		animate();

		function init() {
			var loadStartTime = Date.now();
			var status = document.getElementById("status");
			container = document.createElement('div');
			document.body.appendChild(container);

			var info = document.createElement('div');
			info.style.position = 'absolute';
			info.style.top = '10px';
			info.style.width = '100%';
			info.style.textAlign = 'center';
			info.innerHTML = 'Teapot JSON';
			container.appendChild(info);

			camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 1, 1000);
			camera.position.z = 4;

			scene = new THREE.Scene();
			var ambient = new THREE.AmbientLight(0x444444);
			scene.add(ambient);
			var directionalLight = new THREE.DirectionalLight(0xAFEEEE);
			directionalLight.position.set(0, 0, 1).normalize();
			scene.add(directionalLight);
			status.innerHTML = "Loading...";

			// var objectLoader = new THREE.ObjectLoader();
			// objectLoader.load("teapot-claraio.json", function(obj) {
			// 	root = obj;
			// 	scene.add(obj);
			//
			// });
			var broccoliMaterial = new THREE.MeshBasicMaterial();
			broccoliMaterial.map = THREE.ImageUtils.loadTexture('broccoli.jpg');
			broccoliMaterial.side = THREE.DoubleSide;
			var loader = new THREE.JSONLoader();
			loader.load( 'broccoli.js', function ( geometry ) {
					// var material = new THREE.MeshFaceMaterial(materials);
					// console.log(material);
			    var mesh = new THREE.Mesh( geometry, broccoliMaterial );
					root = mesh;
					mesh.scale.set( 5, 5, 5 );
			    scene.add( mesh );
			});

			renderer = new THREE.WebGLRenderer();
			renderer.setClearColor(0xafeeee);
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(window.innerWidth, window.innerHeight);
			container.appendChild(renderer.domElement);

			stats = new Stats();
			container.appendChild(stats.dom);
			var loadEndTime = Date.now();
			var loadTime = (loadEndTime - loadStartTime) / 1000;
			status.innerHTML = "Load time: " + loadTime.toFixed(2) + " seconds.";
			document.addEventListener('mousedown', onMouseDown, false);
			document.addEventListener('mousemove', onMouseMove, false);
			document.addEventListener('mouseup', onMouseUp, false);

			window.addEventListener('resize', onWindowResize, false);

		}

		function onWindowResize() {

			windowHalfX = window.innerWidth / 2;
			windowHalfY = window.innerHeight / 2;

			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();

			renderer.setSize(window.innerWidth, window.innerHeight);

		}

		var mouseDown = false,
			mouseX = 0,
			mouseY = 0;

		function onMouseMove(evt) {
			if (!mouseDown) {
				return;
			}

			evt.preventDefault();

			var deltaX = evt.clientX - mouseX,
				deltaY = evt.clientY - mouseY;
			mouseX = evt.clientX;
			mouseY = evt.clientY;
			rotateScene(deltaX, deltaY);
		}

		function onMouseDown(evt) {
			evt.preventDefault();

			mouseDown = true;
			mouseX = evt.clientX;
			mouseY = evt.clientY;
		}

		function onMouseUp(evt) {
			evt.preventDefault();

			mouseDown = false;
		}

		function addMouseHandler(canvas) {
			canvas.addEventListener('mousemove', function(e) {
				onMouseMove(e);
			}, false);
			canvas.addEventListener('mousedown', function(e) {
				onMouseDown(e);
			}, false);
			canvas.addEventListener('mouseup', function(e) {
				onMouseUp(e);
			}, false);
		}

		function rotateScene(deltaX, deltaY) {
			// console.log(root);
			root.rotation.y += deltaX / 100;
			root.rotation.x += deltaY / 100;
		}

		//

		// function onDocumentMouseDown( event ) {
		//
		// 	event.preventDefault();
		//
		// 	document.addEventListener( 'mousemove', onDocumentMouseMove, false );
		// 	document.addEventListener( 'mouseup', onDocumentMouseUp, false );
		// 	document.addEventListener( 'mouseout', onDocumentMouseOut, false );
		//
		// 	mouseXOnMouseDown = event.clientX - windowHalfX;
		// 	targetRotationOnMouseDown = targetRotation;
		//
		// }
		//
		// function onDocumentMouseMove( event ) {
		//
		// 	mouseX = event.clientX - windowHalfX;
		//
		// 	targetRotation = targetRotationOnMouseDown + ( mouseX - mouseXOnMouseDown ) * 0.02;
		//
		// }
		//
		// function onDocumentMouseUp( event ) {
		//
		// 	document.removeEventListener( 'mousemove', onDocumentMouseMove, false );
		// 	document.removeEventListener( 'mouseup', onDocumentMouseUp, false );
		// 	document.removeEventListener( 'mouseout', onDocumentMouseOut, false );
		//
		// }
		//
		// function onDocumentMouseOut( event ) {
		//
		// 	document.removeEventListener( 'mousemove', onDocumentMouseMove, false );
		// 	document.removeEventListener( 'mouseup', onDocumentMouseUp, false );
		// 	document.removeEventListener( 'mouseout', onDocumentMouseOut, false );
		//
		// }
		//
		// function onDocumentTouchStart( event ) {
		//
		// 	if ( event.touches.length === 1 ) {
		//
		// 		event.preventDefault();
		//
		// 		mouseXOnMouseDown = event.touches[ 0 ].pageX - windowHalfX;
		// 		targetRotationOnMouseDown = targetRotation;
		//
		// 	}
		//
		// }
		//
		// function onDocumentTouchMove( event ) {
		//
		// 	if ( event.touches.length === 1 ) {
		//
		// 		event.preventDefault();
		//
		// 		mouseX = event.touches[ 0 ].pageX - windowHalfX;
		// 		targetRotation = targetRotationOnMouseDown + ( mouseX - mouseXOnMouseDown ) * 0.05;
		//
		// 	}

		// }


		function animate() {

			requestAnimationFrame(animate);

			stats.begin();
			render();
			stats.end();

		}

		function render() {
			renderer.render(scene, camera);

		}
	</script>

</body>

</html>

<!-- cpu slowdown rate lower for simplistic scenes rotating isn't reproduceable for other file because differences could happen how you interact with it so to make it reproduceable write a script that will manually drag mouse or manually animate object run
tests a few times, take average, discard fastest and slowest -->
