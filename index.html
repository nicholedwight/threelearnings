<!DOCTYPE html>
<html lang="en">

<head>
	<title>three.js canvas - geometry - cube</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<style>
		body {
			font-family: Monospace;
			background-color: #f0f0f0;
			margin: 0px;
			overflow: hidden;
		}
		#status {
				position:absolute;
				width:25%;
				left:2%;
				top:70%;
				height:5%;
				opacity:.9;
				font: 13px/1.231 "Lucida Grande", Lucida, Verdana, sans-serif;
			}
	</style>
</head>

<body>
	<div id="status"></div>
	<script src="js/three.js"></script>

	<script src="js/renderers/Projector.js"></script>
	<script src="js/renderers/CanvasRenderer.js"></script>
	<script src="js/controls/TrackballControls.js"></script>

	<script src="js/libs/stats.min.js"></script>

	<script>
		var container, stats;

		var camera, scene, renderer;

		var cube, plane, root;

		var targetRotation = 0;
		var targetRotationOnMouseDown = 0;

		var mouseX = 0;
		var mouseXOnMouseDown = 0;

		var windowHalfX = window.innerWidth / 2;
		var windowHalfY = window.innerHeight / 2;
		init();
		animate();

		function init() {
			var loadStartTime = Date.now();
			var status = document.getElementById("status");
			container = document.createElement('div');
			document.body.appendChild(container);

			var info = document.createElement('div');
			info.style.position = 'absolute';
			info.style.top = '10px';
			info.style.width = '100%';
			info.style.textAlign = 'center';
			info.innerHTML = 'Teapot JSON';
			container.appendChild(info);

			camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 1, 1000);
			camera.position.z = 4;

			controls = new THREE.TrackballControls( camera );
			controls.rotateSpeed = 2.0;
			controls.zoomSpeed = 1.2;
			controls.panSpeed = 0.8;
			controls.noZoom = false;
			controls.noPan = false;
			controls.staticMoving = true;
			controls.dynamicDampingFactor = 0.3;
			controls.keys = [ 65, 83, 68 ];
			controls.addEventListener( 'change', render );

			scene = new THREE.Scene();
			var ambient = new THREE.AmbientLight(0x444444);
			scene.add(ambient);
			var directionalLight = new THREE.DirectionalLight(0xAFEEEE);
			directionalLight.position.set(0, 0, 1).normalize();
			scene.add(directionalLight);
			status.innerHTML = "Loading...";

			// WORKING BROCCOLI MODEL
			// var broccoliMaterial = new THREE.MeshBasicMaterial();
			// broccoliMaterial.map = THREE.ImageUtils.loadTexture('broccoli.jpg');
			// broccoliMaterial.side = THREE.DoubleSide;
			// var loader = new THREE.JSONLoader();
			// loader.load( 'broccoli.js', function ( geometry ) {
			// 		// var material = new THREE.MeshFaceMaterial(materials);
			// 		// console.log(material);
			//     var mesh = new THREE.Mesh( geometry, broccoliMaterial );
			// 		root = mesh;
			// 		mesh.scale.set( 5, 5, 5 );
			//     scene.add( mesh );
			// });

			// var broccoliMaterial = new THREE.MeshBasicMaterial();
			// broccoliMaterial.map = THREE.ImageUtils.loadTexture('broccoli.jpg');
			// broccoliMaterial.side = THREE.DoubleSide;
			var itmArr = [];
			var loader = new THREE.JSONLoader();
			loader.load( 'glossyteapot.js', function ( geometry, materials ) {
					var material = new THREE.MeshFaceMaterial(materials);
					for (var i =0; i < 40; i++) {
						var mesh = new THREE.Mesh( geometry, material );
						mesh.position.z = (Math.random()-Math.random())*20;
						mesh.position.x = (Math.random()-Math.random())*20;
						mesh.position.y = (Math.random()-Math.random())*20;
						mesh.dir = (Math.random()-Math.random())*.01;
						mesh.scale.set( 0.5, 0.5, 0.5 );
				    scene.add( mesh );
						itmArr.push(mesh);
					}
			});

			function animate(timestamp) {
				for (var i = 0; i <itmArr.length; i++) {
					var itm = itmArr[i];
					if (i%3==0) {
						itm.rotation.x+=itm.dir;
						itm.position.y+=itm.dir/2;
					} else if (i%3==1) {
						itm.rotation.x+=itm.dir;
						itm.position.y+=itm.dir/2;
					} else {
						itm.rotation.x+=itm.dir;
						itm.position.y+=itm.dir/2;
					}
				}
				requestAnimationFrame(animate);
				controls.update();
			}

			animate();

			renderer = new THREE.WebGLRenderer();
			renderer.setClearColor(0xafeeee);
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(window.innerWidth, window.innerHeight);
			container.appendChild(renderer.domElement);

			stats = new Stats();
			container.appendChild(stats.dom);
			var loadEndTime = Date.now();
			var loadTime = (loadEndTime - loadStartTime) / 1000;
			status.innerHTML = "Load time: " + loadTime.toFixed(2) + " seconds.";
			window.addEventListener('resize', onWindowResize, false);

		}

		function onWindowResize() {

			windowHalfX = window.innerWidth / 2;
			windowHalfY = window.innerHeight / 2;

			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();

			renderer.setSize(window.innerWidth, window.innerHeight);

		}

		function animate() {

			requestAnimationFrame(animate);

			stats.begin();
			render();
			stats.end();

		}

		function render() {
			renderer.render(scene, camera);

		}
	</script>

</body>

</html>

<!-- cpu slowdown rate lower for simplistic scenes rotating isn't reproduceable for other file because differences could happen how you interact with it so to make it reproduceable write a script that will manually drag mouse or manually animate object run
tests a few times, take average, discard fastest and slowest -->
